#### 计算机常用存储单位

- 8 bit = 1 Byte **一** 字节
- 1024 B = 1 **K** B （KiloByte） **千** 字节
- 1024 KB = 1 **M** B （MegaByte） **兆** 字节
- 1024 MB = 1 **G** B （GigaByte） **吉** 字节
- 1024 GB = 1 **T** B （TeraByte） **太** 字节
- 1024 TB = 1 **P** B （PetaByte） **拍** 字节
- 1024 PB = 1 **E** B （ExaByte） **艾** 字节
- 1024 EB = 1 **Z** B （ZetaByte） **皆** 字节
- 1024 ZB = 1 **Y** B （YottaByte） **佑** 字节
- 1024 YB = 1 **B** B（Brontobyte） **珀** 字节
- 1024 BB = 1 **N** B （NonaByte） **诺** 字节
- 1024 NB = 1 **D** B （DoggaByte） **刀** 字节

#### 32位软件和64位软件有什么区别？

1. 说个最简单的把，你的内存里最多能放2^32字节，也就是4GB。所以你要读一个超过4GB的东西进内存，就肯定做不到了。（你可以考虑分批读取，一次读1GB。）

2. 我来说个不好的地方，64位下指针变成8字节，很多c结构体占用空间加大，相当于cpu的缓存变小了。

3. 32位和64位的不同：

   - 硬件方面。
     打个不太恰当的比方：原来有个熊孩子数数，他只能数到5，为什么呢？因为他只会数一只手的手指头。所以他对超过5个的东西都没法接受，想不通。突然有一天，这熊孩子的脑瓜开窍啦（cpu升级），会用两只手数数了，现在他终于可以数到10了！
     这就是32位和64位的本质区别，一次性能数的数多了。原先32位要表示内存地址，只能表示4G，所以说超过4G的内存都是没法直接访问的。但是64位不同，它能表示的内存地址是4Gx4G，可以说超过人类短时间内可预见未来的所有需求了。
     另外一个不同是数据存取能力不同，同样一个int64_t类型的数据，在64位机上一次即可取得全部数据，而在32位机上，由于机器字长不足，需要取两次。
   - 软件开发方面。
     这要看你用的什么语言。
     java，python这种高层语言，没有任何变化。不光是源代码，连中间码（byte code）也没有任何不同。平台的不同被虚拟机掩盖了，开发者只要知道，你现在能访问更多的内存资源了（如果你买得起）。你需要做的仅仅是在正确的系统上安装正确的平台版本，比如jdk-7u51-linux-x64.tar.gz，分清x64和x86就好。（x86的能在64位机器上跑起来，反之不行）
     c/c++，除非是涉及硬件底层的代码比如各种驱动，否则源程序理论上不需要做任何变化，只是现在你可以访问更大的地址空间。编译器在不同平台编译出的程序向后兼容。（x86@64bit ok, x64@32bit fail)
   - 普通用户。
     当没这回事就好。如果你一定要刷一点存在感，选择对应系统的对应版本软件，理论上可以达到最大性能。（程序向后兼容）

4. 多少位是指cpu的寄存器宽度不同，比如16位通用寄存器有一个叫ax，这意味着ax寄存器能存储16bit数据, 在32位中这个寄存器是eax，能存储32bit数据。64位中叫rax。

   寻址能力是指cpu寻址总线的宽度。比如16位的x86的u寻址能力是20位，因为寄存器只有16位，所以用seg x16 + offset的方式表示，这就是教科书上所说的逻辑地址。实际上逻辑地址可能产生21位的地址，但是因为寻址总线的宽度只有20所以溢出的一位都会被抛弃。在计算机开机的过程中，bootloader就会读写keyboard controller的60和64端口判断是否开启大于20位的寻址模式。

5. 以我所使用的行业软件为例，64位版本拥有n多倍于32位版本的内存管理能力，(32位版本只能用3g多，还要被系统和其他软件吃一些)，解题能力大大增加，就算不需要那么大的解题能力，对于简单工程来说，因为较少需要用缓慢的硬盘作为中间数据缓存，运算速度也是大大的提升

